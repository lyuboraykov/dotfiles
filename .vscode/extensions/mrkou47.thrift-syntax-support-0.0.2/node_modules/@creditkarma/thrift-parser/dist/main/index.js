"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const debugger_1 = require("./debugger");
const organizer_1 = require("./organizer");
const parser_1 = require("./parser");
const scanner_1 = require("./scanner");
const types_1 = require("./types");
__export(require("./types"));
__export(require("./factory"));
var scanner_2 = require("./scanner");
exports.createScanner = scanner_2.createScanner;
var parser_2 = require("./parser");
exports.createParser = parser_2.createParser;
exports.defaultOptions = {
    fastFail: false,
    rootDir: '.',
    outDir: '.',
    files: [],
    organize: true,
};
function parseFiles(options = {}) {
    const mergedOptions = Object.assign({}, exports.defaultOptions, options);
    return mergedOptions.files.map((file) => {
        const filePath = path.resolve(process.cwd(), mergedOptions.rootDir, file);
        const content = fs.readFileSync(filePath, 'utf-8');
        return parse(content, mergedOptions);
    });
}
exports.parseFiles = parseFiles;
function parse(source, options = {}) {
    const mergedOptions = Object.assign({}, exports.defaultOptions, options);
    const debug = debugger_1.createDebugger(source);
    const scanner = scanner_1.createScanner(source, handleError);
    const tokens = scanner.scan();
    const parser = parser_1.createParser(tokens, handleError);
    const intermediate = parser.parse();
    const thrift = mergedOptions.organize ? organizer_1.organize(intermediate) : intermediate;
    /**
     * This is a safe handler for errors that allows the parser and scanner to recover to a
     * reasonable state after an error and continue with the parse. If an error occurs we will
     * not return any output, but using this allows us to catch more errors and report them to
     * the user at once instead of the work flow of find error -> fix error, find error -> fix error.
     *
     * @param err
     */
    function handleError(err) {
        debug.report(err);
        if (mergedOptions.fastFail) {
            debug.print();
            throw new Error(err.message);
        }
        else {
            switch (err.type) {
                case types_1.ErrorType.ParseError:
                    parser.synchronize();
                    break;
                case types_1.ErrorType.ScanError:
                    scanner.syncronize();
                    break;
            }
        }
    }
    if (debug.hasError()) {
        debug.print();
        return {
            type: types_1.SyntaxType.ThriftErrors,
            errors: debug.getErrors(),
        };
    }
    else {
        return thrift;
    }
}
exports.parse = parse;
//# sourceMappingURL=index.js.map